From 2e81622cc9a60d82bdad867b701e38358dd68879 Mon Sep 17 00:00:00 2001
From: Jacob Stiffler <j-stiffler@ti.com>
Date: Tue, 6 Oct 2015 09:50:38 -0400
Subject: [PATCH] setup-uboot-env-keystone: Add u-boot env setup for keystone
 devices

Signed-off-by: Jacob Stiffler <j-stiffler@ti.com>
---
 setup-uboot-env-keystone.sh | 350 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 350 insertions(+)
 create mode 100755 setup-uboot-env-keystone.sh

diff --git a/setup-uboot-env-keystone.sh b/setup-uboot-env-keystone.sh
new file mode 100755
index 0000000..71e407d
--- /dev/null
+++ b/setup-uboot-env-keystone.sh
@@ -0,0 +1,350 @@
+#!/bin/sh
+
+# This distribution contains contributions or derivatives under copyright
+# as follows:
+#
+# Copyright (c) 2010, Texas Instruments Incorporated
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# - Redistributions of source code must retain the above copyright notice,
+#   this list of conditions and the following disclaimer.
+# - Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in the
+#   documentation and/or other materials provided with the distribution.
+# - Neither the name of Texas Instruments nor the names of its
+#   contributors may be used to endorse or promote products derived
+#   from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+cwd=`dirname $0`
+. $cwd/common.sh
+
+do_expect() {
+    echo "expect {" >> $3
+    check_status
+    echo "    $1" >> $3
+    check_status
+    echo "    timeout 600 goto end" >> $3
+    echo "}" >> $3
+    check_status
+    echo $2 >> $3
+    check_status
+    echo >> $3
+}
+
+copy_to_tftproot() {
+    files="$1"
+    for file in $files
+    do
+	if [ -f $tftproot/$file ]; then
+	    echo
+	    echo "$tftproot/$file already exists. The existing installed file can be renamed and saved under the new name."
+	    echo "(o) overwrite (s) skip copy "
+	    read -p "[o] " exists
+	    case "$exists" in
+	      s) echo "Skipping copy of $file, existing version will be used"
+		 ;;
+	      *) sudo cp "$prebuiltimagesdir/$file" $tftproot
+		 check_status
+		 echo
+		 echo "Successfully overwritten $file in tftp root directory $tftproot"
+		 ;;
+	    esac
+	else
+	    sudo cp "$prebuiltimagesdir/$file" $tftproot
+	    check_status
+	    echo
+	    echo "Successfully copied $file to tftp root directory $tftproot"
+	fi
+    done
+}
+
+echo
+echo "--------------------------------------------------------------------------------"
+echo "This step will set up the u-boot variables for booting the EVM."
+echo "--------------------------------------------------------------------------------"
+
+ipdefault=`ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1 }'`
+platform=`grep PLATFORM= $cwd/../Rules.make | cut -d= -f2`
+
+echo "Autodetected the following ip address of your host, correct it if necessary"
+read -p "[ $ipdefault ] " ip
+echo
+
+if [ ! -n "$ip" ]; then
+    ip=$ipdefault
+fi
+
+if [ -f $cwd/../.tftproot ]; then
+    tftproot=`cat $cwd/../.tftproot`
+else
+    echo "Where is your tftp root directory?"
+    read -p "[ /tftpboot ]" tftproot
+
+    if [ ! -n "$tftproot" ]; then
+        tftproot="/tftpboot"
+    fi
+    echo
+fi
+
+if [ -f $cwd/../.targetfs ]; then
+    rootpath=`cat $cwd/../.targetfs`
+else
+    echo "Where is your target filesystem extracted?"
+    read -p "[ ${HOME}/targetNFS ]" rootpath
+
+    if [ ! -n "$rootpath" ]; then
+        rootpath="${HOME}/targetNFS"
+    fi
+    echo
+fi
+
+
+kernelimage="zImage-""$platform"".bin"
+kernelimagesrc=`ls -1 $cwd/../board-support/prebuilt-images/$kernelimage`
+kernelimagedefault=`basename $kernelimagesrc`
+
+ubootimage="u-boot-spi-${platform}.gph"
+
+ubifsimage="tisdk-server-rootfs-image-${platform}.ubi"
+ubifsimagesrc=`ls -1 $cwd/../filesystem/$ubifsimage`
+ubifsimagedefault=`basename $ubifsimagesrc`
+
+prebuiltimagesdir=`cd $cwd/../filesystem/ ; echo $PWD`
+ubifsimages=`cd $prebuiltimagesdir;ls -1 *.ubi 2> /dev/null`
+copy_to_tftproot "$ubifsimages"
+
+
+echo "--------------------------------------------------------------------------------"
+echo "Would you like to update U-boot on the board (y/n)?"
+read -p "[ y ] " ubootupdate
+echo
+
+if [ ! -n "$ubootupdate" ]; then
+    ubootupdate="y"
+fi
+
+
+echo "Select secondary boot:"
+echo " 1: NFS"
+echo " 2: UBI"
+echo
+read -p "[ 1 ] " secondary_boot
+
+if [ ! -n "$secondary_boot" ]; then
+    secondary_boot="1"
+fi
+
+
+if [ "$secondary_boot" -eq "1" ]; then
+    echo
+    echo "Available kernel images in $tftproot:"
+    for file in $tftproot/*; do
+	basefile=`basename $file`
+	echo "    $basefile"
+    done
+    echo
+    echo "Which kernel image do you want to boot from TFTP?"
+    read -p "[ $kernelimagedefault ] " kernelimage
+
+    if [ ! -n "$kernelimage" ]; then
+	kernelimage=$kernelimagedefault
+    fi
+else
+    echo
+    echo "Available ubi images in $tftproot:"
+    for file in $tftproot/*-${platform}.ubi; do
+	basefile=`basename $file`
+	echo "    $basefile"
+    done
+    echo
+    echo "Which ubi image do you want to boot?"
+    read -p "[ $ubifsimagedefault ] " ubifsimage
+
+    if [ ! -n "$ubifsimage" ]; then
+	ubifsimage=$ubifsimagedefault
+    fi
+    kernelimage=zImage
+fi
+
+board="unknown"
+check_for_board() {
+    lsusb -vv -d 0403:6001 > /dev/null 2>&1
+
+    if [ "$?" = "0" ]
+    then
+        board="x15"
+    fi
+
+    lsusb -vv -d 0403:6010 > /dev/null 2>&1
+
+    if [ "$?" = "0" ]
+    then
+        board="k2hk"
+    fi
+}
+
+echo "timeout 1800" > $cwd/setupBoard.minicom
+echo "verbose on" >> $cwd/setupBoard.minicom
+do_expect "\"stop autoboot:\"" "send \" \"" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send \"env default -f -a\"" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send \"saveenv\"" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send \"reset\"" $cwd/setupBoard.minicom
+do_expect "\"stop autoboot:\"" "send \" \"" $cwd/setupBoard.minicom
+
+do_expect "\"U-Boot#\"" "send \"setenv serverip $ip\"" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send setenv tftp_root '$tftproot'" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send setenv nfs_root '$rootpath'" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send \"setenv name_ubi $ubifsimage\"" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send \"setenv name_kern $kernelimage\"" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send \"setenv name_uboot $ubootimage\"" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send \"saveenv\"" $cwd/setupBoard.minicom
+
+if [ "$ubootupdate" = "y" ]; then
+	do_expect "\"U-Boot#\"" "send \"run get_uboot_net\"" $cwd/setupBoard.minicom
+	do_expect "\"U-Boot#\"" "send \"run burn_uboot_spi\"" $cwd/setupBoard.minicom
+	do_expect "\"U-Boot#\"" "send \"reset\"" $cwd/setupBoard.minicom
+	do_expect "\"stop autoboot:\"" "send \" \"" $cwd/setupBoard.minicom
+fi
+
+if [ "$secondary_boot" -eq "1" ]; then
+	#TFTP and NFS Boot
+	do_expect "\"U-Boot#\"" "send \"setenv boot net\"" $cwd/setupBoard.minicom
+else
+	#SD and NFS Boot
+	do_expect "\"U-Boot#\"" "send \"run get_ubi_net\"" $cwd/setupBoard.minicom
+	do_expect "\"U-Boot#\"" "send \"run burn_ubi\"" $cwd/setupBoard.minicom
+	do_expect "\"U-Boot#\"" "send \"setenv boot ubi\"" $cwd/setupBoard.minicom
+fi
+
+do_expect "\"U-Boot#\"" "send \"saveenv\"" $cwd/setupBoard.minicom
+do_expect "\"U-Boot#\"" "send \"boot\"" $cwd/setupBoard.minicom
+
+echo "end:" >> $cwd/setupBoard.minicom
+echo "! killall -s SIGHUP minicom" >> $cwd/setupBoard.minicom
+
+echo "--------------------------------------------------------------------------------"
+echo "Would you like to create a minicom script with the above parameters (y/n)?"
+read -p "[ y ] " minicom
+echo
+
+if [ ! -n "$minicom" ]; then
+    minicom="y"
+fi
+
+if [ "$minicom" = "y" ]; then
+
+    echo -n "Successfully wrote "
+    readlink -m $cwd/setupBoard.minicom
+
+    while [ yes ]
+    do
+        check_for_board
+
+        if [ "$board" = "k2hk" ]
+        then
+            break
+        else
+            echo ""
+            echo "Board could not be detected. Please connect the board to the PC."
+            read -p "Press any key to try checking again." temp
+        fi
+    done
+
+    if [ "$board" != "unknown" ]
+    then
+        ftdiInstalled=`lsmod | grep ftdi_sio`
+        if [ -z "$ftdiInstalled" ]
+        then
+            sudo modprobe -q ftdi_sio
+        fi
+
+        while [ yes ]
+        do
+            echo ""
+            echo "--------------------------------------------------------------------------------"
+            echo
+            echo -n "Detecting connection to board... "
+            loopCount=0
+            usb_id=`dmesg | grep 'idVendor=0403' | grep 'idProduct=6010' | tail -1 | sed -e 's|.*usb \(.*\):.*|\1|'`
+            port=`dmesg  | grep FTDI | grep "$usb_id" | grep "tty" | tail -2 | head -1 | grep "attached" |  awk '{ print $NF }'`
+            while [ -z "$port" ] && [ "$loopCount" -ne "10" ]
+            do
+                #count to 10 and timeout if no connection is found
+                loopCount=$((loopCount+1))
+
+                sleep 1
+                usb_id=`dmesg | grep 'idVendor=0403' | grep 'idProduct=6010' | tail -1 | sed -e 's|.*usb \(.*\):.*|\1|'`
+                port=`dmesg  | grep FTDI | grep "$usb_id" | grep "tty" | tail -2 | head -1 | grep "attached" |  awk '{ print $NF }'`
+            done
+
+            #check to see if we actually found a port
+            if [ -n "$port" ]; then
+                echo "k2hk-evm connected at /dev/$port"
+                echo
+                break;
+            fi
+
+            #if we didn't find a port and reached the timeout limit then ask to reconnect
+            if [ -z "$port" ] && [ "$loopCount" = "10" ]; then
+                echo ""
+                echo "Unable to detect which port the board is connected to."
+                echo "Please reconnect your board."
+                echo "Press 'y' to attempt to detect your board again or press 'n' to continue..."
+                read -p "(y/n)" retryBoardDetection
+            fi
+
+            #if they choose not to retry, ask user to reboot manually and exit
+            if [ "$retryBoardDetection" = "n" ]; then
+                echo ""
+                echo "Please reboot your board manually and connect using minicom."
+                exit;
+            fi
+        done
+
+        sed -i -e "s|^pu port.*$|pu port             /dev/$port|g" ${HOME}/.minirc.dfl
+    fi
+
+    echo
+    echo "--------------------------------------------------------------------------------"
+    echo "Would you like to run the setup script now (y/n)?"
+    echo
+    echo "Please connect the ethernet cable as described in the Quick Start Guide."
+    echo "Once answering 'y' on the prompt below, you will have 300 seconds to connect"
+    echo "the board and power cycle it before the setup times out"
+    echo
+    echo "After successfully executing this script, your EVM will be set up. You will be "
+    echo "able to connect to it by executing 'minicom -w' or if you prefer a windows host"
+    echo "you can set up Tera Term as explained in the Software Developer's Guide."
+    echo "If you connect minicom or Tera Term and power cycle the board Linux will boot."
+    echo
+    read -p "[ y ] " minicomsetup
+
+    if [ ! -n "$minicomsetup" ]; then
+       minicomsetup="y"
+    fi
+
+    if [ "$minicomsetup" = "y" ]; then
+      cd $cwd
+      sudo minicom -w -S setupBoard.minicom
+      cd -
+    fi
+
+    echo "You can manually run minicom in the future with this setup script using: minicom -S $cwd/setupBoard.minicom"
+    echo "--------------------------------------------------------------------------------"
+
+fi
-- 
1.9.1

