From ed3b0cc4e6066076ec19c7a0039c0a115c4b612f Mon Sep 17 00:00:00 2001
From: WingMan Kwok <w-kwok2@ti.com>
Date: Wed, 28 Feb 2018 14:43:24 -0500
Subject: [PATCH 223/223] net: driver: ti: prueth: handling HSR PTP event
 cut-through tx timestamp

When a HSR non-link-local PTP event is cut-through forward by the
HSR firmware, in addition to the rx timestamp, a tx timestamp is
also provided by the firmware. The tx timestamp is saved in the
shared redundant info area of the received skb before the skb
is passed to upper layer. Currently cut-through tx timestamp is
handled only for HSR PTP over L2 non-link-local event.

tmp: iep: hsr ptp cut-through tx ts processing
tmp: prueth: hsr ptp cut-through tx ts processing
tmp: prueth: passing redinfo hwtstamp to user sapce

Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
---
 drivers/net/ethernet/ti/iep.c    | 18 ++++++++++++++
 drivers/net/ethernet/ti/iep.h    |  1 +
 drivers/net/ethernet/ti/prueth.c | 54 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 73 insertions(+)

diff --git a/drivers/net/ethernet/ti/iep.c b/drivers/net/ethernet/ti/iep.c
index f0fde3d..0f0d67f 100644
--- a/drivers/net/ethernet/ti/iep.c
+++ b/drivers/net/ethernet/ti/iep.c
@@ -775,6 +775,24 @@ int iep_tx_timestamp(struct iep *iep, u16 ts_ofs, struct sk_buff *skb)
 	return 0;
 }
 
+int iep_get_timestamp(struct iep *iep, u16 ts_ofs, u64 *ns)
+{
+	void __iomem *sram = iep->sram;
+	u64 cycles;
+
+	/* get timestamp */
+	memcpy_fromio(&cycles, sram + ts_ofs, sizeof(cycles));
+	memset_io(sram + ts_ofs, 0, sizeof(cycles));
+
+	if (!cycles) {
+		*ns = 0;
+		return -ENOENT;
+	}
+
+	*ns = timecounter_cyc2time(&iep->tc, cycles);
+	return 0;
+}
+
 static int iep_dram_init(struct iep *iep)
 {
 	void __iomem *sram = iep->sram;
diff --git a/drivers/net/ethernet/ti/iep.h b/drivers/net/ethernet/ti/iep.h
index abbb9db..e1d1e38 100644
--- a/drivers/net/ethernet/ti/iep.h
+++ b/drivers/net/ethernet/ti/iep.h
@@ -144,4 +144,5 @@ struct iep {
 struct iep *iep_create(struct device *dev, void __iomem *sram,
 		       void __iomem *iep_reg, int pruss_id);
 void iep_release(struct iep *iep);
+int iep_get_timestamp(struct iep *iep, u16 ts_ofs, u64 *ns);
 #endif
diff --git a/drivers/net/ethernet/ti/prueth.c b/drivers/net/ethernet/ti/prueth.c
index aba185d..23d98f5 100644
--- a/drivers/net/ethernet/ti/prueth.c
+++ b/drivers/net/ethernet/ti/prueth.c
@@ -95,6 +95,12 @@
 module_param(pruss2_mc_mask, charp, 0444);
 MODULE_PARM_DESC(pruss2_mc_mask, "Choose pruss2 MC mask");
 
+static inline bool is_ptp_cut_through_event(u8 ts_msgtype)
+{
+	return (ts_msgtype == PTP_SYNC_MSG_ID) ||
+	       (ts_msgtype == PTP_DLY_REQ_MSG_ID);
+}
+
 static inline int is_hsr_skb(struct sk_buff *skb)
 {
 	unsigned char *p;
@@ -243,6 +249,15 @@ static int pruptp_proc_tx_ts(struct prueth_emac *emac,
 	emac->tx_ev_msg[ts_msgtype] = NULL;
 	spin_unlock_irqrestore(&emac->ev_msg_lock, flags);
 	if (!skb) {
+		/* In case of HSR, tx timestamp may be generated by
+		 * cut-through packets such as SYNC, which does not
+		 * have a corresponding queued tx packet. Such a tx
+		 * timestamp is consumed by the rx port when processing
+		 * the rx timestamp.
+		 */
+		if (PRUETH_HAS_HSR(prueth))
+			return 0;
+
 		netdev_err(emac->ndev,
 			   "no tx msg %u found waiting for ts\n", ts_msgtype);
 		return -ENOMSG;
@@ -360,6 +375,36 @@ static void prueth_clean_ptp_tx_work(void) { }
 
 #endif /* !CONFIG_PREEMPT_RT_FULL */
 
+static int pruptp_hsr_cut_through_tx_ts(struct prueth_emac *emac,
+					struct sk_buff *skb,
+					u8 ts_msgtype)
+{
+	struct prueth *prueth = emac->prueth;
+	struct prueth_emac *other_emac = prueth->emac[emac->port_id ^ 0x3];
+	int other_port_id = other_emac->port_id;
+	u32 ts_ofs;
+	u64 ns;
+	struct skb_shared_hwtstamps *red_ssh;
+
+	ts_ofs = TX_SYNC_TIMESTAMP_OFFSET_P1 +
+		 (other_port_id - 1) * NUM_TS_EVENTS * TS_FIELD_SIZE;
+
+	if (ts_msgtype == PTP_DLY_REQ_MSG_ID)
+		ts_ofs += TS_FIELD_SIZE;
+
+	iep_get_timestamp(prueth->iep, ts_ofs, &ns);
+
+	/* +++TODO: What if the cut-through tx timestamp is
+	 * not available yet?
+	 */
+
+	/* Save the cut-through tx ts in skb redinfo. */
+	red_ssh = skb_redinfo_hwtstamps(skb);
+	memset(red_ssh, 0, sizeof(*red_ssh));
+	red_ssh->hwtstamp = ns_to_ktime(ns);
+	return 0;
+}
+
 static int pruptp_rx_timestamp(struct prueth_emac *emac, struct sk_buff *skb)
 {
 	struct prueth *prueth = emac->prueth;
@@ -404,6 +449,15 @@ static int pruptp_rx_timestamp(struct prueth_emac *emac, struct sk_buff *skb)
 	if (ret < 0) {
 		netdev_err(emac->ndev, "invalid timestamp for rx msg %u\n",
 			   ts_msgtype);
+		return ret;
+	}
+
+	if (PRUETH_HAS_HSR(prueth) && is_ptp_cut_through_event(ts_msgtype)) {
+		/* Received SYNC in HSR mode. That means a copy of it is
+		 * cut-through by fw and a tx ts is available on the other
+		 * port. So save the tx ts in skb's shared redinfo
+		 */
+		pruptp_hsr_cut_through_tx_ts(emac, skb, ts_msgtype);
 	}
 
 	return ret;
-- 
1.9.1

