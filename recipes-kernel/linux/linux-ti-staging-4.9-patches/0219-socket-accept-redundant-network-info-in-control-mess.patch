From d82e4bd9cc66092d40698f57363563aa6d942760 Mon Sep 17 00:00:00 2001
From: WingMan Kwok <w-kwok2@ti.com>
Date: Thu, 19 Apr 2018 01:49:03 -0400
Subject: [PATCH 219/223] socket: accept redundant network info in control
 message

Redundant network info in control message of a submitted packet
is consumed by the HSR/PRP layer to avoid duplication. Such
packet will be sent out through the port indicated by the redundant
network info.

Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
---
 include/net/sock.h     | 13 +++++++++++++
 net/core/sock.c        | 10 ++++++++++
 net/packet/af_packet.c |  2 ++
 3 files changed, 25 insertions(+)

diff --git a/include/net/sock.h b/include/net/sock.h
index 26beaad..99bb74a 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -1505,6 +1505,7 @@ struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,
 struct sockcm_cookie {
 	u32 mark;
 	u16 tsflags;
+	struct skb_redundant_info redinfo;
 };
 
 int __sock_cmsg_send(struct sock *sk, struct msghdr *msg, struct cmsghdr *cmsg,
@@ -2194,6 +2195,18 @@ static inline void sock_recv_redundant_info(struct msghdr *msg, struct sock *sk,
 		put_cmsg(msg, SOL_SOCKET, SCM_REDUNDANT, sizeof(*sred), sred);
 }
 
+static inline void sock_tx_redundant_info(const struct sock *sk,
+					  struct skb_redundant_info *redinfo,
+					  struct sk_buff *skb)
+{
+	struct skb_redundant_info *sred;
+
+	if (redinfo->io_port) {
+		sred = skb_redinfo(skb);
+		memcpy(sred, redinfo, sizeof(*sred));
+	}
+}
+
 /**
  * sk_eat_skb - Release a skb if it is no longer needed
  * @sk: socket to eat this skb from
diff --git a/net/core/sock.c b/net/core/sock.c
index 9819392..ae71dd0 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -1907,6 +1907,7 @@ int __sock_cmsg_send(struct sock *sk, struct msghdr *msg, struct cmsghdr *cmsg,
 		     struct sockcm_cookie *sockc)
 {
 	u32 tsflags;
+	struct skb_redundant_info *cred;
 
 	switch (cmsg->cmsg_type) {
 	case SO_MARK:
@@ -1931,6 +1932,15 @@ int __sock_cmsg_send(struct sock *sk, struct msghdr *msg, struct cmsghdr *cmsg,
 	case SCM_RIGHTS:
 	case SCM_CREDENTIALS:
 		break;
+	case SCM_REDUNDANT:
+		if (cmsg->cmsg_len !=
+		    CMSG_LEN(sizeof(struct skb_redundant_info)))
+			return -EINVAL;
+
+		cred = (struct skb_redundant_info *)CMSG_DATA(cmsg);
+		memcpy(&sockc->redinfo, cred,
+		       sizeof(struct skb_redundant_info));
+		break;
 	default:
 		return -EINVAL;
 	}
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 6d83f48..ed5230e 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -2932,6 +2932,8 @@ static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)
 
 	sock_tx_timestamp(sk, sockc.tsflags, &skb_shinfo(skb)->tx_flags);
 
+	sock_tx_redundant_info(sk, &sockc.redinfo, skb);
+
 	if (!vnet_hdr.gso_type && (len > dev->mtu + reserve + extra_len) &&
 	    !packet_extra_vlan_len_allowed(dev, skb)) {
 		err = -EMSGSIZE;
-- 
1.9.1

