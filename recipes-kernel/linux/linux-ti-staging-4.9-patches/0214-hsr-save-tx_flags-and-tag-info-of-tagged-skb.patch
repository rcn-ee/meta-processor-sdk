From e3e8b6759229387d08017f864310135aff90a0de Mon Sep 17 00:00:00 2001
From: WingMan Kwok <w-kwok2@ti.com>
Date: Fri, 16 Feb 2018 10:50:52 -0500
Subject: [PATCH 214/223] hsr: save tx_flags and tag info of tagged skb

After a tag is created for an egress skb, the tag info and slave port
info is saved in the skb's shared info area so that the saved info can
be returned to user space application by upper core layer.

In this patch, only the support of saving HSR tag info of HSR PTP
over L2 skb is added.

Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
---
 net/hsr-prp/hsr_prp_forward.c | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/net/hsr-prp/hsr_prp_forward.c b/net/hsr-prp/hsr_prp_forward.c
index 4c32189..4f529c7 100644
--- a/net/hsr-prp/hsr_prp_forward.c
+++ b/net/hsr-prp/hsr_prp_forward.c
@@ -33,6 +33,16 @@ struct hsr_prp_frame_info {
 	bool is_from_san;
 };
 
+static inline int is_hsr_l2ptp(struct sk_buff *skb)
+{
+	struct hsr_ethhdr *hsr_ethhdr;
+
+	hsr_ethhdr = (struct hsr_ethhdr *)skb_mac_header(skb);
+
+	return (hsr_ethhdr->ethhdr.h_proto == htons(ETH_P_HSR) &&
+		hsr_ethhdr->hsr_tag.encap_proto == htons(ETH_P_1588));
+}
+
 /* The uses I can see for these HSR supervision frames are:
  * 1) Use the frames that are sent after node initialization ("HSR_TLV.Type =
  *    22") to reset any sequence_nr counters belonging to that node. Useful if
@@ -269,6 +279,9 @@ static struct sk_buff *create_tagged_skb(struct sk_buff *skb_o,
 	int movelen;
 	unsigned char *dst, *src;
 	struct sk_buff *skb;
+	struct skb_redundant_info *sred;
+	struct hsr_ethhdr *hsr_ethhdr;
+	u16 s;
 
 	if (port->priv->prot_version > HSR_V1) {
 		skb = skb_copy_expand(skb_o, skb_headroom(skb_o),
@@ -303,6 +316,22 @@ static struct sk_buff *create_tagged_skb(struct sk_buff *skb_o,
 
 	hsr_fill_tag(skb, frame, port, port->priv->prot_version);
 
+	skb_shinfo(skb)->tx_flags = skb_shinfo(skb_o)->tx_flags;
+	skb->sk = skb_o->sk;
+
+	/* TODO: should check socket option instead? */
+	if (is_hsr_l2ptp(skb)) {
+		sred = skb_redinfo(skb);
+		/* assumes no vlan */
+		hsr_ethhdr = (struct hsr_ethhdr *)skb_mac_header(skb);
+		sred->io_port = port->type;
+		sred->ethertype = ntohs(hsr_ethhdr->ethhdr.h_proto);
+		s = ntohs(hsr_ethhdr->hsr_tag.path_and_LSDU_size);
+		sred->lsdu_size = s & 0xfff;
+		sred->pathid = (s >> 12) & 0xf;
+		sred->seqnr = hsr_get_skb_sequence_nr(skb);
+	}
+
 	return skb;
 }
 
-- 
1.9.1

