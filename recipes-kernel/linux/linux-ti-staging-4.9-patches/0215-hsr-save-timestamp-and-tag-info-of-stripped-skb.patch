From 19f8f20c5820edfa7b32ca3fb4ad6a8ce143f339 Mon Sep 17 00:00:00 2001
From: WingMan Kwok <w-kwok2@ti.com>
Date: Fri, 16 Feb 2018 11:26:54 -0500
Subject: [PATCH 215/223] hsr: save timestamp and tag info of stripped skb

Before the tag is stripped from a received skb, the tag info and
receive timestamp is saved in the shared info area of the skb so
that upper core layer can pass the saved info to user application.

In this patch the support of saving tag info and timestamp is added for
HSR PTP packets over L2.

Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
---
 net/hsr-prp/hsr_prp_forward.c | 59 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 57 insertions(+), 2 deletions(-)

diff --git a/net/hsr-prp/hsr_prp_forward.c b/net/hsr-prp/hsr_prp_forward.c
index 4f529c7..7e244a6 100644
--- a/net/hsr-prp/hsr_prp_forward.c
+++ b/net/hsr-prp/hsr_prp_forward.c
@@ -43,6 +43,23 @@ static inline int is_hsr_l2ptp(struct sk_buff *skb)
 		hsr_ethhdr->hsr_tag.encap_proto == htons(ETH_P_1588));
 }
 
+static inline int is_hsr_l2ptp_evt(struct sk_buff *skb)
+{
+	unsigned char *p;
+
+	if (!skb->data)
+		return 0;
+
+	p = skb->data;
+
+	/* FIXME: should use macros to access header fields */
+	return (*(p + 12) == 0x89 && *(p + 13) == 0x2f &&  /* HSR */
+		*(p + 18) == 0x88 && *(p + 19) == 0xf7 &&  /* PTP */
+		(*(p + 20) == 0x00 ||
+		 *(p + 20) == 0x02 ||
+		 *(p + 20) == 0x03));                      /* EVT */
+}
+
 /* The uses I can see for these HSR supervision frames are:
  * 1) Use the frames that are sent after node initialization ("HSR_TLV.Type =
  *    22") to reset any sequence_nr counters belonging to that node. Useful if
@@ -416,6 +433,41 @@ static int hsr_prp_xmit(struct sk_buff *skb, struct hsr_prp_port *port,
 	return dev_queue_xmit(skb);
 }
 
+static void stripped_skb_get_shared_info(struct sk_buff *skb_stripped,
+					 struct hsr_prp_frame_info *frame)
+{
+	struct hsr_prp_port *port_rcv = frame->port_rcv;
+	struct sk_buff *skb_hsr, *skb;
+	struct skb_redundant_info *sred;
+	struct hsr_ethhdr *hsr_ethhdr;
+	u16 s;
+
+	if (port_rcv->priv->prot_version > HSR_V1)
+		return;
+
+	if (!frame->skb_hsr)
+		return;
+
+	skb_hsr = frame->skb_hsr;
+	skb = skb_stripped;
+
+	if (is_hsr_l2ptp_evt(skb_hsr))
+		skb_hwtstamps(skb)->hwtstamp = skb_hwtstamps(skb_hsr)->hwtstamp;
+
+	if (is_hsr_l2ptp(skb_hsr)) {
+		sred = skb_redinfo(skb);
+		/* assumes no vlan */
+		hsr_ethhdr = (struct hsr_ethhdr *)skb_mac_header(skb_hsr);
+		/* 0x80 => out port */
+		sred->io_port = (0x80 | port_rcv->type);
+		sred->ethertype = ntohs(hsr_ethhdr->ethhdr.h_proto);
+		s = ntohs(hsr_ethhdr->hsr_tag.path_and_LSDU_size);
+		sred->lsdu_size = s & 0xfff;
+		sred->pathid = (s >> 12) & 0xf;
+		sred->seqnr = frame->sequence_nr;
+	}
+}
+
 /* Forward the frame through all devices except:
  * - Back through the receiving device
  * - If it's a HSR frame: through a device where it has passed before
@@ -487,11 +539,14 @@ static void hsr_prp_forward_do(struct hsr_prp_frame_info *frame)
 		     (port->type ==  HSR_PRP_PT_SLAVE_A))))
 			continue;
 
-		if (port->type != HSR_PRP_PT_MASTER)
+		if (port->type != HSR_PRP_PT_MASTER) {
 			skb = frame_get_tagged_skb(frame, port);
-		else
+		} else {
 			skb = frame_get_stripped_skb(frame, port);
 
+			stripped_skb_get_shared_info(skb, frame);
+		}
+
 		if (!skb) {
 			if (frame->port_rcv->type == HSR_PRP_PT_SLAVE_A ||
 			    frame->port_rcv->type ==  HSR_PRP_PT_SLAVE_B)
-- 
1.9.1

